[[promoting-integration]]
= Promoting Integrations across environments

As soon as you have an Integration running in your cluster, you will be challenged to move that Integration to an higher environment. Ie, you can test your Integration in a **development** environment, and, as soon as you're happy with the result, you will need to move it into a **production** environment.

[[cli-promote]]
== CLI `promote` command

Camel K has an opinionated way to achieve the promotion goal through the usage of `kamel promote` command. With this command you will be able to easily move an Integration from one namespace to another without worrying about any low level detail such as resources needed by the Integration. You only need to make sure that both the source operator and the destination operator are using the same container registry and that the destination namespace provides the required Configmaps, Secrets or Kamelets required by the Integration.

NOTE: use dry run option (`-o yaml`) and export the result to any separated cluster or Git repository to perform a GitOps strategy.

Let's see a simple Integration that uses a Configmap to expose some message on an HTTP endpoint. We can start creating such an Integration and testing in a namespace called `development`:

```
kubectl create configmap my-cm --from-literal=greeting="hello, I am development!" -n development
```
.PromoteServer.java
```java
import org.apache.camel.builder.RouteBuilder;

public class PromoteServer extends RouteBuilder {
  @Override
  public void configure() throws Exception {
    from("platform-http:/hello?httpMethodRestrict=GET").setBody(simple("resource:classpath:greeting"));
  }
}
```
Let's run it:
```
kamel run --dev -n development PromoteServer.java --config configmap:my-cm [-t service.node-port=true]
```
Note that you may need to tweak the service trait, depending on the Kubernetes platform and the level of exposure you want to provide. As soon as it is finished, we can test it as well:
```
curl http://192.168.49.2:32116/hello
hello, I am development!
```

Now let's say we're happy with the testing of our Integration and we're ready to move it to a production environment. We need to have the destination environment (a Kubernetes namespace) ready with an operator (sharing the same operator source container registry) and any configuration, such as the configmap we have used here. For that scope, let's create one on the destination namespace:
```
kubectl create configmap my-cm --from-literal=greeting="hello, I am production!" -n production
```
Please, note that for security reason, there is a check to make sure that the expected resources such as Configmaps, Secrets and Kamelets are present on the destination. If any is missing, the Integration won't be moved. We can now "promote" our Integration:
```
kamel promote promote-server -n development --to production
kamel logs promote-server -n production
```
Let's test the promoted Integration:
```
curl http://192.168.49.2:30764/hello
hello, I am production!
```
Something nice is that since the Integration is reusing the very same container image, the execution of the new application will be immediate. Also from a release perspective we are guaranteeing the **immutability** of the Integration as the container used is exactly the same of the one we have tested in development (what we change are just the configurations).

Please notice that the Integration running in test is not altered in any way and will be running until any user will stop it.

[[traits]]
== Moving traits

NOTE: this feature is available starting from version 2.5

When you use the `promote` subcommand, you're also keeping the status of any configured trait along with the new promoted Integration. The tool is in fact in charge to recover the trait configuration of the source Integration and port it over to the new Integration promoted.

This is particularly nice when you have certain traits which are requiring the scan the source code (for instance, Service trait). In this way, when you promote the new Integration, the traits will be automatically configured to copy any parameter, replicating the very exact behavior between the source and destination environment.

With this approach, you won't need to worry any longer about any trait which was requiring the source to be attached in order to automatically scan for features.

[[gitops]]
== GitOps

NOTE: this feature is available starting from version 2.6

The promote has also the possibility to create a Kustomize based overlay structure in order to simplify the creation of a **GitOps based deployment** process. Let's pretend we want to create a GitOps pipeline for two environments, as an example, *staging* and *production*. For each environment we can call the export command:

```
$ kamel promote promote-server -n development --to staging --export-gitops-dir /tmp/integrations
$ kamel promote promote-server -n development --to production --export-gitops-dir /tmp/integrations
```

NOTE: you can call this command for as many environments you manage

The result will be a directory with the following structure:

```
$ tree /tmp/integrations/
/tmp/integrations/
└── promote-server
    ├── base
    │   ├── integration.yaml
    │   └── kustomization.yaml
    ├── overlays
    │   ├── production
    │   │   ├── kustomization.yaml
    │   │   └── patch-integration.yaml
    │   └── staging
    │       ├── kustomization.yaml
    │       └── patch-integration.yaml
    └── routes
        └── PromoteServer.java

6 directories, 7 files
```
The `promote-server` directory contains the Integration named as `promote-server` (the one we created in the previous chapter). Then, you can see a *base* directory which contains the base Integration custom resource. Additionally you will find the *staging* and *production* overlays which contains the patches you may want to apply in each given environment.

```
$ cat /tmp/integrations/promote-server/overlays/production/patch-integration.yaml
apiVersion: camel.apache.org/v1
kind: Integration
metadata:
  creationTimestamp: null
  name: promote-server
spec:
  traits:
    mount:
      configs:
      - configmap:my-cm
status: {}
```

The CLI has a predetermined set of configuration (traits) which are typically subject of environment patching, such as Camel properties or any Kubernetes resource configuration. You will need to change those parameters accordingly or add any one else required for your specific use case.

The above structure could be used directly with `kubectl` (eg, `kubectl apply -k /tmp/integrations/promote-server/overlays/production`). For this reason it can be used *as is* to feed a Git repository and referenced in any CICD pipeline.

=== Running Camel with ArgoCD

Once you have stored the project in a Git repository, if you're using a CICD technology like https://argo-cd.readthedocs.io[ArgoCD] you can run immediately your *production* pipeline as:

```
argocd app create my-ck-it-prod --repo https://git-server/repo/promote-server.git --path overlays/production --dest-server https://kubernetes.default.svc --dest-namespace prod
```

From this moment onward any change can be performed on the repository and it will be automatically refreshed by the CICD pipeline accordingly.

NOTE: any other CICD technology can be adopted using the Git repository as source.

=== Predetermined configuration

The CLI will add a patch configuration for any of the following trait configuration found in the source base Integration:

* Affinity configuration
* Camel properties
* Container resources
* Environment variables
* JVM options
* Mount configuration
* Toleration configuration

NOTE: feel free to ask to add any further configuration you require.

=== Automated GitOps with GitHub Integration

NOTE: this feature is available starting from version 2.7

The `--push-gitops-dir` flag extends the GitOps functionality by automatically committing changes to git and creating a GitHub Pull Request. This provides a complete GitOps automation workflow:

```
$ kamel promote promote-server -n development --to production --export-gitops-dir /tmp/integrations --push-gitops-dir
Exported a Kustomize based Gitops directory to /tmp/integrations for "promote-server" Integration
Created git commit with the GitOps base overlay
Created GitHub PR with the base overlay from exported GitOps directory: https://github.com/owner/repo/pull/123
```

==== Git Workflow

When using `--push-gitops-dir`, the following automated workflow is executed:

1. **Export GitOps structure** - Creates the Kustomize base/overlays directory structure
2. **Create git branch** - Generates a new branch named `camel-k-gitops-export-{timestamp}`
3. **Commit changes** - Stages and commits only the base overlay files to git
4. **Push to remote** - Pushes the new branch to the configured git remote
5. **Create GitHub PR** - Opens a Pull Request against the currently checked out branch

IMPORTANT: Only the base overlay files are committed to git. The environment-specific overlays are created locally but not committed, allowing teams to manage environment configurations separately.

==== Prerequisites

Before using `--push-gitops-dir`, ensure the following requirements are met:

* The GitOps directory must be within a git repository
* The current HEAD must be a branch (not a detached HEAD)
* The base branch must exist on the remote repository
* Appropriate authentication must be configured (see Authentication section below)

==== Authentication

===== GitHub Token (Required)

Set the `GITHUB_TOKEN` environment variable for both git push (HTTPS URLs) and GitHub PR creation:

```
export GITHUB_TOKEN=ghp_your_token_here
```

The token requires the following permissions:
* `repo` scope for private repositories
* `public_repo` scope for public repositories

===== Git Authentication

**HTTPS URLs (Recommended):**

For HTTPS git URLs (e.g., `https://github.com/owner/repo.git`), authentication is handled automatically using the `GITHUB_TOKEN`:

```
git remote set-url origin https://github.com/owner/repo.git
```

**SSH URLs:**

For SSH git URLs (e.g., `git@github.com:owner/repo.git`), ensure proper SSH key configuration:

```
# Add GitHub's public key to known_hosts
ssh-keyscan -t ecdsa github.com >> ~/.ssh/known_hosts

# Test SSH connection
ssh -T git@github.com
```

If you have multiple SSH keys, you can specify which key to use:

```
export KAMEL_SSH_KEY_PATH=/path/to/your/private/key
export KAMEL_SSH_KEY_PASSPHRASE=your_passphrase  # if key is encrypted
```

Alternatively, configure SSH to use the correct key:

```
# Add to ~/.ssh/config
Host github.com
    IdentityFile ~/.ssh/your_github_key
    IdentitiesOnly yes
```

==== Error Handling

Common issues and solutions:

**Base branch validation error:**
```
Error: git repository "path" HEAD must be a branch, but is: refs/heads/detached
```
Solution: Checkout a proper branch before running the command.

**Remote branch not found:**
```
Error: 422 Validation Failed [{Resource:PullRequest Field:base Code:invalid Message:}]
```
Solution: Ensure the current branch exists on the remote repository.

**SSH authentication failure:**
```
Error: ssh: handshake failed: knownhosts: key mismatch
```
Solution: Update known_hosts with GitHub's current public keys using `ssh-keyscan`.

==== Branch Management

The command creates a new feature branch for each promotion to avoid conflicts. The Pull Request is created against the branch that was checked out when the promote command was executed. This allows teams to:

* Work on multiple promotions simultaneously
* Review changes before merging
* Maintain a clean git history
* Integrate with existing GitOps workflows

Example workflow:
```
# Start from main branch
git checkout main

# Promote and create PR against main
kamel promote my-integration -n dev --to prod --export-gitops-dir ./gitops --push-gitops-dir

# The PR will be created with base branch = main
# Head branch = camel-k-gitops-export-{timestamp}
```
